package problems;

import java.util.ArrayList;

public class ProblemSet {
  /**
   *
   * @param m1
   * @param m2
   * @param ceiling
   * @return
   */
  public int problem001(int m1, int m2, int ceiling) {
    /*
     * Problem 1: Multiples of 3 and 5
     *
     * If we list all the natural numbers below 10 that are multiples of
     * 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
     *
     * Find the sum of all the multiples of 3 or 5 below 1000.
     *
     */


    /* The naive method would be to iterate through each integer less
     * than 1000 and keep a running total of all that are evenly
     * divisible by either 3 or 5, with O(n) running time.
     *
     * A better approach is to compute the answer as the sum of
     * arithmetic series, i.e. the sum of the multiples of three plus
     * the sum of the multiples of 5. However, any integers that are
     * multiples of 15 will have been added twice, so we need to
     * subtract that sum
     */

    return arithmeticSum(m1, ceiling)
         + arithmeticSum(m2, ceiling)
         - arithmeticSum(m1 * m2, ceiling);

  }

  /**
   *
   * @param divisor
   * @param ceiling
   * @return
   */
  public int problem002(int divisor, int ceiling) {
    /*
     * Problem 2: Even Fibonacci numbers
     *
     * Each new term in the Fibonacci sequence is generated by adding
     * the previous two terms. by starting with 1 and 2, the first 10
     * terms will be:
     *
     *     1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
     *
     * By considering the terms in the Fibonacci sequence whose values
     * do not exceed four million, find the sum of the even-valued
     * terms.
     */
    int sum = 0;
    int nLess2 = 0;
    int nLess1 = 1;
    while (true) {
      nLess1 += nLess2;
      nLess2 = nLess1 - nLess2;
      if (nLess1 > ceiling) {
        break;
      }
      if (nLess1 % divisor == 0) {
        sum += nLess1;
      }
    }

    return sum;
  }

/**
 *
 * @param n
 * @return largest prime factor of n
 */

  public Long problem003(long n) {
    PrimesGenerator primes = new PrimesGenerator();
    Long factor = 1L;
    while (n > 1) {
      factor = primes.next();

      if (factor > Math.sqrt(n)) {
        factor = n;
      }

      while (n % factor == 0) {
        n = n / factor;
      }
    }

    return factor;
  }



  /*
   * Utility functions
   */

  /**
   *
   * @param step
   * @param ceiling
   * @return
   */
  private int arithmeticSum(int step, int ceiling) {
    int count = (ceiling - 1) / step;
    int largestMultiple = count * step;
    return (largestMultiple + step) * count / 2;
  }

  /**
   *
   * @param n
   * @return
   */
  public boolean isPrime(long n) {
    if (n == 1) {
      return false;
    }
    long i = 2;
    long sqrt = (int)Math.sqrt(n);
    while (i <= sqrt) {
      if (n % i == 0) {
        return false;
      }
      i++;
    }
    return true;
  }

  class PrimesGenerator {
    public ArrayList<Long> primes = new ArrayList<Long>();
    private int i = 0;

    public PrimesGenerator() {
      this.primes.add(2L);
      this.primes.add(3L);
    }

    public Long next() {
      Long nextPrime;
      if (this.i < this.primes.size()) {
        nextPrime = primes.get(this.i);
      }
      else {
        Long candidate = this.primes.get(this.primes.size() - 1) + 2;
        while (true) {
          boolean isPrime = true;
          for (int j = 0; j < this.primes.size(); j++) {
            if (candidate % this.primes.get(j) == 0) {
              isPrime = false;
              break;
            }
          }
          if (isPrime) {
            this.primes.add(candidate);
            nextPrime = candidate;
            break;
          }
          candidate += 2;
        }
      }
      this.i++;
      return nextPrime;
    }
  }

}


