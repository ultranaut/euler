package problems;

public class ProblemSet {
  /**
   *
   * @param m1
   * @param m2
   * @param ceiling
   * @return
   */
  public int problem001(int m1, int m2, int ceiling) {
    /*
     * Problem 1: Multiples of 3 and 5
     *
     * If we list all the natural numbers below 10 that are multiples of
     * 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
     *
     * Find the sum of all the multiples of 3 or 5 below 1000.
     *
     */


    /* The naive method would be to iterate through each integer less
     * than 1000 and keep a running total of all that are evenly
     * divisible by either 3 or 5, with O(n) running time.
     *
     * A better approach is to compute the answer as the sum of
     * arithmetic series, i.e. the sum of the multiples of three plus
     * the sum of the multiples of 5. However, any integers that are
     * multiples of 15 will have been added twice, so we need to
     * subtract that sum
     */

    return arithmeticSum(m1, ceiling)
         + arithmeticSum(m2, ceiling)
         - arithmeticSum(m1 * m2, ceiling);

  }

  /**
   *
   * @param divisor
   * @param ceiling
   * @return
   */
  public int problem002(int divisor, int ceiling) {
    /*
     * Problem 2: Even Fibonacci numbers
     *
     * Each new term in the Fibonacci sequence is generated by adding
     * the previous two terms. by starting with 1 and 2, the first 10
     * terms will be:
     *
     *     1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
     *
     * By considering the terms in the Fibonacci sequence whose values
     * do not exceed four million, find the sum of the even-valued
     * terms.
     */
    int sum = 0;
    int nLess2 = 0;
    int nLess1 = 1;
    while (true) {
      nLess1 += nLess2;
      nLess2 = nLess1 - nLess2;
      if (nLess1 > ceiling) {
        break;
      }
      if (nLess1 % divisor == 0) {
        sum += nLess1;
      }
    }

    return sum;
  }

/**
 *
 * @param n
 * @return largest prime factor of n
 */

  public Long problem003(long n) {
    /*
     * Problem 3: Largest prime factor
     *
     * The prime factors of 13195 are 5, 7, 13 and 29.
     *
     * What is the largest prime factor of the number 600851475143 ?
     */

    PrimesGenerator primes = new PrimesGenerator();
    Long factor = 1L;
    while (n > 1) {
      // get the next prime number
      factor = primes.next();

      // if the factor is larger than the square root of n, then n is prime
      // and we can just set factor to n
      if (factor > Math.sqrt(n)) {
        factor = n;
      }

      while (n % factor == 0) {
        n = n / factor;
      }
    }

    return factor;
  }

  public long problem005(int n) {
    /*
     * Problem 5: Smallest multiple
     *
     * 2520 is the smallest number that can be divided by each of the
     * numbers from 1 to 10 without any remainder.
     *
     * What is the smallest positive number that is evenly divisible by
     * all of the numbers from 1 to 20?
     */
    PrimesGenerator primes = new PrimesGenerator();

    long product = 1;

    while (true) {
      long p = primes.next();
      if (p > n) {
        break;
      }


      /*
      * First pass: for each of the primes less than or equal to n, see
      * which of our numbers has the highest power of two as a factor,
      * and multiply the running product total by that amount
      */

      // high-water mark of the exponent for our current prime
      int exp = 0;

      // cycle through each of the multiples of p up to n and check how
      // many times p will go into it
      for (long number = p; number < n+1; number += p) {
        int count = 0;

        while (number % Math.pow(p, count+1) == 0) {
          count++;
        }
        if (count > exp) {
          exp = count;
        }
      }


      /*
      * second go: way simpler, but only works if all of the numbers up
      * to n are used, i.e. it wouldn't work with some sub-set of
      * numbers, or an arbitrary set of numbers
      */
      /*
      int exp = (int)(Math.log(n) / Math.log(p));
      */


      product *= Math.pow(p, exp);
    }

    return product;
  }

  public long problem006(int n) {
    /*
     * Problem 6: Sum square difference
     *
     * The sum of the squares of the first ten natural numbers is,
     *
     *     12 + 22 + ... + 102 = 385
     *
     * The square of the sum of the first ten natural numbers is,
     *
     *     (1 + 2 + ... + 10)2 = 552 = 3025
     *
     * Hence the difference between the sum of the squares of the first
     * ten natural numbers and the square of the sum is
     *
     *     3025 − 385 = 2640.

     * Find the difference between the sum of the squares of the first
     * one hundred natural numbers and the square of the sum.
     */

    long sumOfSquares = 0;
    long sumOfAll = 0;
    long squareOfSum = 0;

    /*  // naive approach, O(n) runtime...
    for (int i = 1; i <= n; i++) {
      sumOfAll += i;
      sumOfSquares += (long)Math.pow(i, 2);
    }
    */

    // ...however, both sums can be directly computed, O(1) runtime:
    sumOfAll = n * (n + 1) / 2;
    sumOfSquares = n*(n + 1)*(2*n + 1) / 6;

    squareOfSum = (long)Math.pow(sumOfAll, 2);


    return squareOfSum - sumOfSquares;

  }

  public long problem008(int[] digits) {
    /*
     * Problem 8: Largest product in a series
     *
     * The four adjacent digits in the 1000-digit number that have the
     * greatest product are 9 × 9 × 8 × 9 = 5832.
     *
     *     73167176531330624919225119674426574742355349194934
     *     96983520312774506326239578318016984801869478851843
     *     85861560789112949495459501737958331952853208805511
     *     12540698747158523863050715693290963295227443043557
     *     66896648950445244523161731856403098711121722383113
     *     62229893423380308135336276614282806444486645238749
     *     30358907296290491560440772390713810515859307960866
     *     70172427121883998797908792274921901699720888093776
     *     65727333001053367881220235421809751254540594752243
     *     52584907711670556013604839586446706324415722155397
     *     53697817977846174064955149290862569321978468622482
     *     83972241375657056057490261407972968652414535100474
     *     82166370484403199890008895243450658541227588666881
     *     16427171479924442928230863465674813919123162824586
     *     17866458359124566529476545682848912883142607690042
     *     24219022671055626321111109370544217506941658960408
     *     07198403850962455444362981230987879927244284909188
     *     84580156166097919133875499200524063689912560717606
     *     05886116467109405077541002256983155200055935729725
     *     71636269561882670428252483600823257530420752963450
     *
     * Find the thirteen adjacent digits in the 1000-digit number that
     * have the greatest product. What is the value of this product?
     */
    int digitCount = digits.length;

    long max = 0;

    int lo = 0;
    int hi = 13;
    long product = 1;

    while (hi < digitCount) {
      product = getProduct(digits, lo, hi);
      if (product != 0) {
        if (product > max) {
          max = product;
        }
        lo++;
        hi++;
      } else {
        while (digits[lo] != 0) {
          lo++;
          hi++;
        }
        lo++;
        hi++;
      }
    }
    return max;
  }

  public long getProduct(int[] list, int lo, int hi) {
    long product = 1;
    for (int i = lo; i < hi; i++) {
      product *= list[i];
    }
    return product;
  }


  /*
   * Utility functions
   */

  /**
   *
   * @param step
   * @param ceiling
   * @return
   */
  private int arithmeticSum(int step, int ceiling) {
    int count = (ceiling - 1) / step;
    int largestMultiple = count * step;
    return (largestMultiple + step) * count / 2;
  }
}


